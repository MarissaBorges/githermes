:   Generate the file names in a directory tree by walking the tree
    either top-down or bottom-up.

    For each directory in the directory tree rooted at *self* (including
    *self* but excluding ‘.’ and ‘..’), the method yields a 3-tuple of
    `(dirpath, dirnames, filenames)`.

    *dirpath* is a [`Path`](#pathlib.Path "pathlib.Path") to the directory currently being walked,
    *dirnames* is a list of strings for the names of subdirectories in *dirpath*
    (excluding `'.'` and `'..'`), and *filenames* is a list of strings for
    the names of the non-directory files in *dirpath*. To get a full path
    (which begins with *self*) to a file or directory in *dirpath*, do
    `dirpath / name`. Whether or not the lists are sorted is file
    system-dependent.

    If the optional argument *top\_down* is true (which is the default), the triple for a
    directory is generated before the triples for any of its subdirectories
    (directories are walked top-down). If *top\_down* is false, the triple
    for a directory is generated after the triples for all of its subdirectories
    (directories are walked bottom-up). No matter the value of *top\_down*, the
    list of subdirectories is retrieved before the triples for the directory and
    its subdirectories are walked.

    When *top\_down* is true, the caller can modify the *dirnames* list in-place
    (for example, using [`del`](../reference/simple_stmts.html#del) or slice assignment), and [`Path.walk()`](#pathlib.Path.walk "pathlib.Path.walk")
    will only recurse into the subdirectories whose names remain in *dirnames*.
    This can be used to prune the search, or to impose a specific order of visiting,
    or even to inform [`Path.walk()`](#pathlib.Path.walk "pathlib.Path.walk") about directories the caller creates or
    renames before it resumes [`Path.walk()`](#pathlib.Path.walk "pathlib.Path.walk") again. Modifying *dirnames* when
    *top\_down* is false has no effect on the behavior of [`Path.walk()`](#pathlib.Path.walk "pathlib.Path.walk") since the
    directories in *dirnames* have already been generated by the time *dirnames*
    is yielded to the caller.

    By default, errors from [`os.scandir()`](os.html#os.scandir "os.scandir") are ignored. If the optional
    argument *on\_error* is specified, it should be a callable; it will be
    called with one argument, an [`OSError`](exceptions.html#OSError "OSError") instance. The callable can handle the
    error to continue the walk or re-raise it to stop the walk. Note that the
    filename is available as the `filename` attribute of the exception object.

    By default, [`Path.walk()`](#pathlib.Path.walk "pathlib.Path.walk") does not follow symbolic links, and instead adds them
    to the *filenames* list. Set *follow\_symlinks* to true to resolve symlinks
    and place them in *dirnames* and *filenames* as appropriate for their targets, and
    consequently visit directories pointed to by symlinks (where supported).

    Note

    Be aware that setting *follow\_symlinks* to true can lead to infinite
    recursion if a link points to a parent directory of itself. [`Path.walk()`](#pathlib.Path.walk "pathlib.Path.walk")
    does not keep track of the directories it has already visited.

    Note

    [`Path.walk()`](#pathlib.Path.walk "pathlib.Path.walk") assumes the directories it walks are not modified during
    execution. For example, if a directory from *dirnames* has been replaced
    with a symlink and *follow\_symlinks* is false, [`Path.walk()`](#pathlib.Path.walk "pathlib.Path.walk") will
    still try to descend into it. To prevent such behavior, remove directories
    from *dirnames* as appropriate.

    Note

    Unlike [`os.walk()`](os.html#os.walk "os.walk"), [`Path.walk()`](#pathlib.Path.walk "pathlib.Path.walk") lists symlinks to directories in
    *filenames* if *follow\_symlinks* is false.

    This example displays the number of bytes used by all files in each directory,
    while ignoring `__pycache__` directories:

    Copy

    ```
    from pathlib import Path
    for root, dirs, files in Path("cpython/Lib/concurrent").walk(on_error=print):
      print(
          root,
          "consumes",
          sum((root / file).stat().st_size for file in files),
          "bytes in",
          len(files),
          "non-directory files"
      )
      if '__pycache__' in dirs:
            dirs.remove('__pycache__')

    ```

    This next example is a simple implementation of [`shutil.rmtree()`](shutil.html#shutil.rmtree "shutil.rmtree").
    Walking the tree bottom-up is essential as [`rmdir()`](#pathlib.Path.rmdir "pathlib.Path.rmdir") doesn’t allow
    deleting a directory before it is empty:

    Copy

    ```
    # Delete everything reachable from the directory "top".
    # CAUTION:  This is dangerous! For example, if top == Path('/'),
    # it could delete all of your files.
    for root, dirs, files in top.walk(top_down=False):
        for name in files:
            (root / name).unlink()
        for name in dirs:
            (root / name).rmdir()

    ```